Vamos a ver cÃ³mo hacer ordenamientos y operaciones con punteros en C++ sin usar POO, es decir, solo con programaciÃ³n estructurada.
Esto te servirÃ¡ para entender cÃ³mo manipular memoria directamente, hacer ordenamientos eficientes y practicar paso por referencia.

ğŸ§  1ï¸âƒ£ Repaso: QuÃ© es un puntero

Un puntero es una variable que guarda la direcciÃ³n de memoria de otra variable.

int x = 10;
int* p = &x; // p guarda la direcciÃ³n de x


ğŸ‘‰ *p accede al valor.
ğŸ‘‰ p guarda la direcciÃ³n.
ğŸ‘‰ &x es la direcciÃ³n de x.

ğŸ”¢ 2ï¸âƒ£ Crear y usar arreglos con punteros

En C++, un arreglo se puede manejar con punteros porque el nombre del arreglo ya es un puntero al primer elemento:

int numeros[] = {5, 2, 9, 1, 3};
int* ptr = numeros; // ptr apunta a numeros[0]


Ejemplo para recorrer el arreglo con punteros:

for (int i = 0; i < 5; i++) {
    cout << *(ptr + i) << " ";
}

ğŸ§® 3ï¸âƒ£ Intercambio de valores con punteros

Fundamental para ordenamientos:

void intercambiar(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

ğŸ”„ 4ï¸âƒ£ Ordenamiento con punteros (Burbuja)

Burbuja es el mÃ¡s fÃ¡cil para aprender con punteros.

#include <iostream>
using namespace std;

void intercambiar(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void ordenarBurbuja(int* arr, int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (*(arr + j) > *(arr + j + 1)) {
                intercambiar(arr + j, arr + j + 1);
            }
        }
    }
}

int main() {
    int datos[] = {5, 1, 4, 2, 8};
    int n = 5;

    ordenarBurbuja(datos, n);

    cout << "Ordenado: ";
    for (int i = 0; i < n; i++) {
        cout << *(datos + i) << " ";
    }
}

âš™ï¸ 5ï¸âƒ£ Operaciones Ãºtiles con punteros y arreglos
OperaciÃ³n	Ejemplo	DescripciÃ³n
Suma de elementos	suma += *(ptr + i);	Accede a cada valor
Buscar elemento	if (*(ptr + i) == valor)	Comparar por posiciÃ³n
Copiar arreglo	*(dest + i) = *(src + i);	Copia manual con punteros
Contar pares	if (*(ptr + i) % 2 == 0)	CondiciÃ³n directa

Ejemplo prÃ¡ctico:

int sumaArreglo(int* arr, int n) {
    int suma = 0;
    for (int i = 0; i < n; i++)
        suma += *(arr + i);
    return suma;
}

ğŸ” 6ï¸âƒ£ Ordenamiento por selecciÃ³n (Selection Sort) con punteros
void ordenarSeleccion(int* arr, int n) {
    for (int i = 0; i < n - 1; i++) {
        int* min = arr + i;
        for (int j = i + 1; j < n; j++) {
            if (*(arr + j) < *min)
                min = arr + j;
        }
        intercambiar(min, arr + i);
    }
}

âš¡ 7ï¸âƒ£ Ordenamiento por inserciÃ³n (Insertion Sort) con punteros
void ordenarInsercion(int* arr, int n) {
    for (int i = 1; i < n; i++) {
        int clave = *(arr + i);
        int j = i - 1;
        while (j >= 0 && *(arr + j) > clave) {
            *(arr + j + 1) = *(arr + j);
            j--;
        }
        *(arr + j + 1) = clave;
    }
}

ğŸ’¡ 8ï¸âƒ£ Reservar memoria dinÃ¡mica (new y delete)

Cuando no conoces el tamaÃ±o del arreglo hasta la ejecuciÃ³n:

int n;
cout << "TamaÃ±o: ";
cin >> n;

int* arr = new int[n]; // reserva memoria

for (int i = 0; i < n; i++)
    cin >> *(arr + i);

ordenarBurbuja(arr, n);

delete[] arr; // libera memoria

ğŸ§° 9ï¸âƒ£ Otras operaciones comunes con punteros

Invertir arreglo

void invertir(int* arr, int n) {
    int* inicio = arr;
    int* fin = arr + n - 1;
    while (inicio < fin) {
        intercambiar(inicio, fin);
        inicio++;
        fin--;
    }
}


Encontrar mÃ¡ximo y mÃ­nimo

int maximo(int* arr, int n) {
    int max = *arr;
    for (int i = 1; i < n; i++)
        if (*(arr + i) > max)
            max = *(arr + i);
    return max;
}

âš ï¸ ğŸ”¥ 10ï¸âƒ£ Errores y excepciones comunes con punteros
Error	Causa	SoluciÃ³n
Segmentation fault	Acceso fuera del rango o puntero nulo	Verificar lÃ­mites y punteros antes de usar
Memory leak	No usar delete[] tras new[]	Liberar memoria al final
Invalid read	Usar puntero ya liberado	Evitar acceder despuÃ©s de delete[]
Punteros colgantes	Retornar direcciÃ³n de variable local	Usar memoria dinÃ¡mica o static
ConfusiÃ³n * y &	Operadores mal usados	Recordar: & â†’ direcciÃ³n, * â†’ valor
ğŸ§© 11ï¸âƒ£ Resumen de ordenamientos con punteros
MÃ©todo	Complejidad	CuÃ¡ndo usarlo	ImplementaciÃ³n fÃ¡cil
Burbuja	O(nÂ²)	Cuando estÃ¡s aprendiendo	âœ… SÃ­
SelecciÃ³n	O(nÂ²)	Cuando quieres menos intercambios	âœ… SÃ­
InserciÃ³n	O(nÂ²)	Para arreglos casi ordenados	âœ… SÃ­
QuickSort	O(n log n)	Arreglos grandes (avanzado)	âš™ï¸ No sin recursiÃ³n
MergeSort	O(n log n)	Muy eficiente y estable	âš™ï¸ Requiere recursiÃ³n